{"problem_type1": "For an integer x find the largest positive integer y, which doesn't exceed x, and has the maximum sum of digits. \n\n-----Input-----\n\nThe positive integer x \n\n-----Output-----\n\nPrint y.\n\n-----Examples-----\nInput\n100\n\nOutput\n99\n\nInput\n48\n\nOutput\n48", "problem_type2": "Given n, how many structurally unique BST's (binary search trees) that store values 1 ...\u00a0n?\n\nExample:\n\nInput: 3\nOutput: 5", "solution_type1": "x = int(input())\nif x < 10:\n    print(x)\nelif x == int(str(x)[0] + '9'*(len(str(x))-1)):\n    print(x)\nelse:\n    a = str(x)[0] + '9' * (len(str(x)) - 1)\n    a = list(a)\n    for i in range(len(a) - 1, -1, -1):\n        k = a[i]\n        a[i] = str(int(a[i]) - 1)\n        if x >= int(''.join(a)):\n            print(int(''.join(a)))\n            break\n        a[i] = k\n", "solution_type2": "class Solution:\n     def numTrees(self, n):\n         res = [0] * (n+1)\n         res[0] = res[1] = 1            \n         for i in range(2,n+1):\n             for j in range(1,i+1):\n                 res[i] += res[j-1] * res[i-j]\n         return res[-1]"}